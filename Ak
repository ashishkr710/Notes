// src/middleware/upload.ts

import multer from 'multer';
import path from 'path';

// Storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    if (file.fieldname === 'profilePic') {
      cb(null, 'uploads/profilePhotos/');
    } else if (file.fieldname === 'appointmentLetter') {
      cb(null, 'uploads/appointmentLetters/');
    } else {
      cb(null, 'uploads/others/');
    }
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

// File filter to accept only specific file types
const fileFilter = (req: Express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  if (file.fieldname === 'profilePic') {
    // Accept images only
    if (!file.mimetype.startsWith('image/')) {
      return cb(new Error('Only image files are allowed for profile pictures'), false);
    }
  } else if (file.fieldname === 'appointmentLetter') {
    // Accept PDFs only
    if (file.mimetype !== 'application/pdf') {
      return cb(new Error('Only PDF files are allowed for appointment letters'), false);
    }
  }
  cb(null, true);
};

// Initialize multer
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5 MB limit
});

export default upload;


// src/controllers/userController.ts

import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import User from '../models/user';
import Address from '../models/address';
import config from '../utils/validateEnv';

// Helper function to generate JWT
const generateToken = (id: number) => {
  return jwt.sign({ id }, config.jwtSecret, { expiresIn: '1h' });
};

// Add a new user
export const addUser = async (req: Request, res: Response) => {
  try {
    const {
      firstName,
      lastName,
      email,
      companyAddress,
      companyCity,
      companyState,
      companyZip,
      homeAddress,
      homeCity,
      homeState,
      homeZip,
    } = req.body;

    // Validate mandatory fields on server side
    if (
      !firstName ||
      !lastName ||
      !email ||
      !companyAddress ||
      !companyCity ||
      !companyState ||
      !companyZip ||
      !homeAddress ||
      !homeCity ||
      !homeState ||
      !homeZip
    ) {
      return res.status(400).json({ message: 'All fields are required' });
    }

    // Check if email already exists
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already exists' });
    }

    // Hash password (assuming password is provided; if not, adjust accordingly)
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash('defaultPassword123', salt); // Replace with actual password if available

    // Handle file uploads
    let profilePicPath = '';
    let appointmentLetterPath = '';

    if (req.file) {
      // Handle single file uploads if necessary
    }

    if (req.files) {
      const files = req.files as Express.Multer.File[];

      if (files['profilePic'] && files['profilePic'][0]) {
        profilePicPath = files['profilePic'][0].path;
      }

      if (files['appointmentLetter'] && files['appointmentLetter'][0]) {
        appointmentLetterPath = files['appointmentLetter'][0].path;
      }
    }

    // Create user
    const user = await User.create({
      firstName,
      lastName,
      email,
      password: hashedPassword,
      profilePic: profilePicPath,
      appointmentLetter: appointmentLetterPath,
    });

    // Create company address
    await Address.create({
      userId: user.id,
      addressType: 'company',
      address: companyAddress,
      city: companyCity,
      state: companyState,
      zip: companyZip,
    });

    // Create home address
    await Address.create({
      userId: user.id,
      addressType: 'home',
      address: homeAddress,
      city: homeCity,
      state: homeState,
      zip: homeZip,
    });

    res.status(201).json({ message: 'User added successfully', userId: user.id });
  } catch (error) {
    console.error('Error adding user:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// View a user's details
export const viewUser = async (req: Request, res: Response) => {
  try {
    const userId = req.params.id;

    const user = await User.findByPk(userId, {
      attributes: { exclude: ['password'] },
      include: [
        {
          model: Address,
          as: 'addresses',
          attributes: ['addressType', 'address', 'city', 'state', 'zip'],
        },
      ],
    });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(user);
  } catch (error) {
    console.error('Error viewing user:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Edit a user's details
export const editUser = async (req: Request, res: Response) => {
  try {
    const userId = req.params.id;

    const {
      firstName,
      lastName,
      email,
      companyAddress,
      companyCity,
      companyState,
      companyZip,
      homeAddress,
      homeCity,
      homeState,
      homeZip,
    } = req.body;

    // Validate mandatory fields on server side
    if (
      !firstName ||
      !lastName ||
      !email ||
      !companyAddress ||
      !companyCity ||
      !companyState ||
      !companyZip ||
      !homeAddress ||
      !homeCity ||
      !homeState ||
      !homeZip
    ) {
      return res.status(400).json({ message: 'All fields are required' });
    }

    const user = await User.findByPk(userId, {
      include: [{ model: Address, as: 'addresses' }],
    });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if email is being updated to an existing one
    if (email !== user.email) {
      const emailExists = await User.findOne({ where: { email } });
      if (emailExists) {
        return res.status(400).json({ message: 'Email already exists' });
      }
      user.email = email;
    }

    user.firstName = firstName;
    user.lastName = lastName;

    // Handle file uploads
    if (req.files) {
      if (req.files['profilePic'] && req.files['profilePic'][0]) {
        user.profilePic = req.files['profilePic'][0].path;
      }

      if (req.files['appointmentLetter'] && req.files['appointmentLetter'][0]) {
        user.appointmentLetter = req.files['appointmentLetter'][0].path;
      }
    }

    await user.save();

    // Update company address
    const companyAddressEntry = user.addresses.find(
      (addr) => addr.addressType === 'company'
    );
    if (companyAddressEntry) {
      companyAddressEntry.address = companyAddress;
      companyAddressEntry.city = companyCity;
      companyAddressEntry.state = companyState;
      companyAddressEntry.zip = companyZip;
      await companyAddressEntry.save();
    }

    // Update home address
    const homeAddressEntry = user.addresses.find(
      (addr) => addr.addressType === 'home'
    );
    if (homeAddressEntry) {
      homeAddressEntry.address = homeAddress;
      homeAddressEntry.city = homeCity;
      homeAddressEntry.state = homeState;
      homeAddressEntry.zip = homeZip;
      await homeAddressEntry.save();
    }

    res.json({ message: 'User updated successfully' });
  } catch (error) {
    console.error('Error editing user:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

https://chatgpt.com/share/66ff79c6-5788-8008-b69b-50bfb3012966
