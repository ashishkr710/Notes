### Switching Backend from TypeORM to Sequelize

Sequelize is a powerful **ORM (Object-Relational Mapping)** library for **Node.js** that supports **TypeScript**. Unlike TypeORM, which uses decorators extensively, Sequelize offers a different approach to defining models and managing database interactions. This guide will help you transition your backend from **TypeORM** to **Sequelize** while maintaining the use of **Express.js**, **MySQL**, and **TypeScript**.

---

### **1. Setup**

#### **a. Initialize the Project**

If you haven't already, create a new directory for your backend and initialize it with `npm`:

```bash
mkdir backend
cd backend
npm init -y
```

#### **b. Install Dependencies**

Install the necessary runtime and development dependencies:

```bash
# Install runtime dependencies
npm install express bcryptjs jsonwebtoken cors dotenv sequelize mysql2

# Install development dependencies
npm install -D typescript ts-node-dev @types/express @types/node @types/bcryptjs @types/jsonwebtoken @types/cors @types/sequelize
```

**Packages Explanation:**

- **express**: Web framework for Node.js.
- **bcryptjs**: For hashing passwords.
- **jsonwebtoken**: For JWT authentication.
- **cors**: To handle Cross-Origin Resource Sharing.
- **dotenv**: To manage environment variables.
- **sequelize**: ORM for Node.js supporting MySQL.
- **mysql2**: MySQL client for Node.js compatible with Sequelize.

#### **c. Initialize TypeScript**

Initialize TypeScript configuration:

```bash
npx tsc --init
```

Modify the `tsconfig.json` to suit the project. Here's a recommended configuration:

```json
{
  "compilerOptions": {
    "target": "ES6",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "types": ["node", "express"]
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

**Key Changes:**

- **rootDir** and **outDir**: Define source and output directories.
- **types**: Include type definitions for Node.js and Express.

#### **d. Project Structure**

Create the following folder structure:

```
backend/
├── src/
│   ├── controllers/
│   │   └── userController.ts
│   ├── middleware/
│   │   └── auth.ts
│   ├── models/
│   │   └── user.ts
│   ├── routes/
│   │   └── userRoutes.ts
│   ├── config/
│   │   └── database.ts
│   ├── utils/
│   │   └── validateEnv.ts
│   ├── app.ts
│   └── server.ts
├── .env
├── package.json
├── tsconfig.json
```

---

### **2. Configuration**

#### **a. Environment Variables**

Create a `.env` file in the root of the `backend` directory to store environment variables:

```env
PORT=5000
DB_HOST=localhost
DB_PORT=3306
DB_USERNAME=your_mysql_username
DB_PASSWORD=your_mysql_password
DB_DATABASE=your_database_name
JWT_SECRET=your_jwt_secret_key
```

**Notes:**

- Replace `your_mysql_username`, `your_mysql_password`, and `your_database_name` with your actual MySQL credentials and desired database name.
- Ensure that the MySQL server is running and accessible with the provided credentials.

#### **b. Validate Environment Variables**

Create a utility to validate environment variables.

**`src/utils/validateEnv.ts`**

```typescript
import dotenv from 'dotenv';

dotenv.config();

const requiredEnvVars = [
  'PORT',
  'DB_HOST',
  'DB_PORT',
  'DB_USERNAME',
  'DB_PASSWORD',
  'DB_DATABASE',
  'JWT_SECRET',
];

requiredEnvVars.forEach((key) => {
  if (!process.env[key]) {
    console.error(`Error: Missing environment variable ${key}`);
    process.exit(1);
  }
});

export default {
  port: process.env.PORT || 5000,
  db: {
    host: process.env.DB_HOST!,
    port: parseInt(process.env.DB_PORT!, 10),
    username: process.env.DB_USERNAME!,
    password: process.env.DB_PASSWORD!,
    database: process.env.DB_DATABASE!,
  },
  jwtSecret: process.env.JWT_SECRET!,
};
```

---

### **3. Database Connection with Sequelize**

Sequelize requires establishing a connection to the database. We'll create a configuration file for this purpose.

**`src/config/database.ts`**

```typescript
import { Sequelize } from 'sequelize';
import config from '../utils/validateEnv';

const sequelize = new Sequelize(
  config.db.database,
  config.db.username,
  config.db.password,
  {
    host: config.db.host,
    port: config.db.port,
    dialect: 'mysql',
    logging: false, // Disable logging; enable if you need to debug
  }
);

export default sequelize;
```

---

### **4. Define the User Model**

With Sequelize, models are defined using the `Model` class. We'll create a `User` model to represent users in the database.

**`src/models/user.ts`**

```typescript
import { DataTypes, Model, Optional } from 'sequelize';
import sequelize from '../config/database';

// Define the attributes for the User model
interface UserAttributes {
  id: number;
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  dateOfBirth?: Date;
  gender?: 'male' | 'female';
  phoneNumber?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// Some attributes are optional when creating a new User
interface UserCreationAttributes extends Optional<UserAttributes, 'id'> {}

class User extends Model<UserAttributes, UserCreationAttributes> implements UserAttributes {
  public id!: number;
  public firstName!: string;
  public lastName!: string;
  public email!: string;
  public password!: string;
  public dateOfBirth?: Date;
  public gender?: 'male' | 'female';
  public phoneNumber?: string;

  // Timestamps
  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;
}

User.init(
  {
    id: {
      type: DataTypes.INTEGER.UNSIGNED,
      autoIncrement: true,
      primaryKey: true,
    },
    firstName: {
      type: new DataTypes.STRING(100),
      allowNull: false,
    },
    lastName: {
      type: new DataTypes.STRING(100),
      allowNull: false,
    },
    email: {
      type: new DataTypes.STRING(255),
      allowNull: false,
      unique: true,
      validate: {
        isEmail: { msg: 'Must be a valid email address' },
      },
    },
    password: {
      type: new DataTypes.STRING(255),
      allowNull: false,
    },
    dateOfBirth: {
      type: DataTypes.DATEONLY,
      allowNull: true,
    },
    gender: {
      type: DataTypes.ENUM('male', 'female'),
      allowNull: true,
    },
    phoneNumber: {
      type: new DataTypes.STRING(20),
      allowNull: true,
    },
  },
  {
    tableName: 'users',
    sequelize, // passing the `sequelize` instance is required
  }
);

export default User;
```

**Field Explanations:**

- **id**: Primary key, auto-incremented.
- **firstName** & **lastName**: User's names.
- **email**: Unique identifier for login.
- **password**: Hashed password.
- **dateOfBirth**, **gender**, **phoneNumber**: Additional profile information.
- **createdAt** & **updatedAt**: Timestamps managed by Sequelize.

---

### **5. Middleware for Authentication**

Create middleware to protect routes using JWT.

**`src/middleware/auth.ts`**

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import config from '../utils/validateEnv';
import User from '../models/user';

interface AuthRequest extends Request {
  user?: typeof User;
}

const auth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.header('Authorization');

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'No token, authorization denied' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, config.jwtSecret) as { id: number };
    const user = await User.findByPk(decoded.id, { attributes: { exclude: ['password'] } });

    if (!user) {
      return res.status(401).json({ message: 'Token is not valid' });
    }

    req.user = user;
    next();
  } catch (error) {
    console.error(error);
    res.status(401).json({ message: 'Token is not valid' });
  }
};

export default auth;
```

---

### **6. User Controller**

Handle user-related operations such as signup, login, profile retrieval, and profile updates.

**`src/controllers/userController.ts`**

```typescript
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import User from '../models/user';
import config from '../utils/validateEnv';

// Helper function to generate JWT
const generateToken = (id: number) => {
  return jwt.sign({ id }, config.jwtSecret, { expiresIn: '1h' });
};

// @desc    Register new user
// @route   POST /api/signup
// @access  Public
export const signup = async (req: Request, res: Response) => {
  const { firstName, lastName, email, password } = req.body;

  try {
    // Check if user exists
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already exists' });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Create user
    const user = await User.create({
      firstName,
      lastName,
      email,
      password: hashedPassword,
    });

    res.status(201).json({ message: 'User registered successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// @desc    Authenticate user & get token
// @route   POST /api/login
// @access  Public
export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;

  try {
    // Check for user
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return res.status(400).json({ message: 'Invalid Credentials' });
    }

    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid Credentials' });
    }

    // Generate JWT
    const token = generateToken(user.id);

    res.json({ token });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// @desc    Get user profile
// @route   GET /api/profile
// @access  Private
export const getProfile = async (req: Request, res: Response) => {
  const user = (req as any).user;

  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }

  res.json({
    firstName: user.firstName,
    lastName: user.lastName,
    email: user.email,
    dateOfBirth: user.dateOfBirth,
    gender: user.gender,
    phoneNumber: user.phoneNumber,
  });
};

// @desc    Update user profile
// @route   PUT /api/profile
// @access  Private
export const updateProfile = async (req: Request, res: Response) => {
  const user = (req as any).user;
  const { firstName, lastName, email, dateOfBirth, gender, phoneNumber } = req.body;

  try {
    // Check if email is being updated and if it's unique
    if (email && email !== user.email) {
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return res.status(400).json({ message: 'Email already exists' });
      }
      user.email = email;
    }

    // Update fields
    if (firstName) user.firstName = firstName;
    if (lastName) user.lastName = lastName;
    if (dateOfBirth) user.dateOfBirth = dateOfBirth;
    if (gender) user.gender = gender;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    await user.save();

    res.json({ message: 'Profile updated successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};
```

---

### **7. Define Routes**

Set up routes to handle API endpoints.

**`src/routes/userRoutes.ts`**

```typescript
import express from 'express';
import { signup, login, getProfile, updateProfile } from '../controllers/userController';
import auth from '../middleware/auth';

const router = express.Router();

// Public Routes
router.post('/signup', signup);
router.post('/login', login);

// Protected Routes
router.get('/profile', auth, getProfile);
router.put('/profile', auth, updateProfile);

export default router;
```

---

### **8. Initialize Express App**

Set up the Express application with necessary middleware and routes.

**`src/app.ts`**

```typescript
import express from 'express';
import cors from 'cors';
import userRoutes from './routes/userRoutes';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/api', userRoutes);

// Health Check Route
app.get('/', (req, res) => {
  res.send('API is running...');
});

export default app;
```

---

### **9. Start the Server**

Configure the server to connect to the database and start listening for requests.

**`src/server.ts`**

```typescript
import app from './app';
import sequelize from './config/database';
import config from './utils/validateEnv';
import User from './models/user';

// Function to initialize the database and start the server
const startServer = async () => {
  try {
    await sequelize.authenticate();
    console.log('Database connected');

    // Sync all models
    await sequelize.sync(); // { force: true } to drop tables and recreate

    app.listen(config.port, () => {
      console.log(`Server running on port ${config.port}`);
    });
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1);
  }
};

startServer();
```

**Notes:**

- **sequelize.sync()**: Synchronizes all defined models with the database. In production, consider using migrations instead of `sync()` to manage database schema changes more safely.

---

### **10. Scripts in `package.json`**

Add the following scripts to your `package.json` for development and production:

```json
"scripts": {
  "build": "tsc",
  "start": "node dist/server.js",
  "dev": "ts-node-dev --respawn --transpile-only src/server.ts"
},
```

- **`npm run dev`**: Starts the server in development mode with automatic restarts.
- **`npm run build`**: Compiles TypeScript to JavaScript.
- **`npm start`**: Starts the compiled JavaScript server.

---

### **11. Running the Backend**

#### **a. Set Up MySQL Database**

1. **Install MySQL**: If you haven't installed MySQL, download and install it from the [official website](https://www.mysql.com/downloads/).

2. **Create Database**:

   ```sql
   CREATE DATABASE your_database_name;
   ```

   Replace `your_database_name` with the name you specified in your `.env` file.

3. **Create User (Optional)**:

   ```sql
   CREATE USER 'your_mysql_username'@'localhost' IDENTIFIED BY 'your_mysql_password';
   GRANT ALL PRIVILEGES ON your_database_name.* TO 'your_mysql_username'@'localhost';
   FLUSH PRIVILEGES;
   ```

#### **b. Start the Backend Server**

Ensure MySQL is running and accessible with the credentials provided in your `.env` file.

Start the backend server in development mode:

```bash
npm run dev
```

**Expected Output:**

```
Database connected
Server running on port 5000
```

---

### **12. API Endpoints Summary**

1. **Signup**

   - **URL:** `POST /api/signup`
   - **Body:**

     ```json
     {
       "firstName": "John",
       "lastName": "Doe",
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```

   - **Responses:**
     - `201 Created`: User registered successfully.
     - `400 Bad Request`: Email already exists.
     - `500 Internal Server Error`: Server error.

2. **Login**

   - **URL:** `POST /api/login`
   - **Body:**

     ```json
     {
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```

   - **Responses:**
     - `200 OK`: Returns JWT token.

       ```json
       {
         "token": "your_jwt_token"
       }
       ```

     - `400 Bad Request`: Invalid credentials.
     - `500 Internal Server Error`: Server error.

3. **Get Profile**

   - **URL:** `GET /api/profile`
   - **Headers:**

     ```
     Authorization: Bearer your_jwt_token
     ```

   - **Responses:**
     - `200 OK`: Returns user profile.

       ```json
       {
         "firstName": "John",
         "lastName": "Doe",
         "email": "john.doe@example.com",
         "dateOfBirth": "1990-01-01",
         "gender": "male",
         "phoneNumber": "1234567890"
       }
       ```

     - `401 Unauthorized`: No token or invalid token.
     - `500 Internal Server Error`: Server error.

4. **Update Profile**

   - **URL:** `PUT /api/profile`
   - **Headers:**

     ```
     Authorization: Bearer your_jwt_token
     ```

   - **Body:** (Any fields to update)

     ```json
     {
       "firstName": "Jane",
       "email": "jane.doe@example.com"
     }
     ```

   - **Responses:**
     - `200 OK`: Profile updated successfully.
     - `400 Bad Request`: Email already exists or validation error.
     - `401 Unauthorized`: No token or invalid token.
     - `500 Internal Server Error`: Server error.

---

### **13. CORS Configuration**

By default, CORS is enabled for all origins in `app.ts` with `app.use(cors())`. If you want to restrict it to specific origins (e.g., your frontend URL), modify the CORS middleware.

**Example: Restricting to `http://localhost:3000`**

**`src/app.ts`**

```typescript
import express from 'express';
import cors from 'cors';
import userRoutes from './routes/userRoutes';
import config from './utils/validateEnv';

const app = express();

// Middleware
const corsOptions = {
  origin: 'http://localhost:3000', // Replace with your frontend URL
  optionsSuccessStatus: 200,
};

app.use(cors(corsOptions));
app.use(express.json());

// Routes
app.use('/api', userRoutes);

// Health Check Route
app.get('/', (req, res) => {
  res.send('API is running...');
});

export default app;
```

---

### **14. Testing the API**

You can use tools like **Postman**, **Insomnia**, or **cURL** to test the API endpoints.

**Example Workflow:**

1. **Signup:**

   - **Request:** `POST /api/signup`
   - **Body:**

     ```json
     {
       "firstName": "John",
       "lastName": "Doe",
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```

   - **Expected Response:** `201 Created` with message "User registered successfully".

2. **Login:**

   - **Request:** `POST /api/login`
   - **Body:**

     ```json
     {
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```

   - **Expected Response:** `200 OK` with a JWT token.

     ```json
     {
       "token": "your_jwt_token"
     }
     ```

3. **Get Profile:**

   - **Request:** `GET /api/profile`
   - **Headers:**

     ```
     Authorization: Bearer your_jwt_token
     ```

   - **Expected Response:** `200 OK` with user profile data.

4. **Update Profile:**

   - **Request:** `PUT /api/profile`
   - **Headers:**

     ```
     Authorization: Bearer your_jwt_token
     ```

   - **Body:**

     ```json
     {
       "firstName": "Jane",
       "email": "jane.doe@example.com"
     }
     ```

   - **Expected Response:** `200 OK` with message "Profile updated successfully".

---

### **15. Security Considerations**

- **Password Security:** Passwords are hashed using `bcryptjs` before storing them in the database.
- **JWT Security:** Ensure that the `JWT_SECRET` is strong and kept confidential. Tokens have an expiration time (`1h` in this case).
- **Error Handling:** Avoid exposing sensitive information in error messages.
- **CORS:** Restrict CORS to only allow trusted origins.
- **Environment Variables:** Never commit your `.env` file to version control. Use environment variables securely, especially in production.
- **Production Considerations:**
  - **Migrations:** Use Sequelize migrations instead of `sequelize.sync()` to manage database schema changes safely.
  - **HTTPS:** Serve your API over HTTPS to ensure encrypted data transmission.
  - **Rate Limiting:** Implement rate limiting to protect against brute-force attacks.
  - **Logging:** Implement proper logging for monitoring and debugging.
  - **Input Validation:** Enhance validation to prevent SQL in
