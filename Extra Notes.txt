### Backend Implementation for the Full-Stack Application

We'll build the backend using **Node.js**, **Express.js**, and **MongoDB** with **Mongoose**. We'll use **TypeScript** for type safety and better development experience. The backend will handle user authentication using **JWT** and manage user data through RESTful APIs.

#### **1. Setup**

##### **a. Initialize the Project**

First, create a new directory for your backend and initialize it with `npm`:

```bash
mkdir backend
cd backend
npm init -y
```

##### **b. Install Dependencies**

Install the necessary packages:

```bash
# Install runtime dependencies
npm install express mongoose bcryptjs jsonwebtoken cors dotenv

# Install development dependencies
npm install -D typescript ts-node-dev @types/express @types/node @types/bcryptjs @types/jsonwebtoken @types/cors
```

##### **c. Initialize TypeScript**

Initialize TypeScript configuration:

```bash
npx tsc --init
```

Modify the `tsconfig.json` to suit the project. Here's a basic configuration:

```json
{
  "compilerOptions": {
    "target": "ES6",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true
  }
}
```

##### **d. Project Structure**

Create the following folder structure:

```
backend/
├── src/
│   ├── controllers/
│   │   └── userController.ts
│   ├── middleware/
│   │   └── auth.ts
│   ├── models/
│   │   └── User.ts
│   ├── routes/
│   │   └── userRoutes.ts
│   ├── utils/
│   │   └── validateEnv.ts
│   ├── app.ts
│   └── server.ts
├── .env
├── package.json
├── tsconfig.json
```

#### **2. Configuration**

##### **a. Environment Variables**

Create a `.env` file in the root of the `backend` directory to store environment variables:

```env
PORT=5000
MONGO_URI=your_mongodb_connection_string
JWT_SECRET=your_jwt_secret_key
```

**Note:** Replace `your_mongodb_connection_string` with your actual MongoDB connection string and `your_jwt_secret_key` with a strong secret key.

##### **b. Validate Environment Variables**

Create a utility to validate environment variables.

**`src/utils/validateEnv.ts`**

```typescript
import dotenv from 'dotenv';

dotenv.config();

const requiredEnvVars = ['PORT', 'MONGO_URI', 'JWT_SECRET'];

requiredEnvVars.forEach((key) => {
  if (!process.env[key]) {
    console.error(`Error: Missing environment variable ${key}`);
    process.exit(1);
  }
});

export default {
  port: process.env.PORT || 5000,
  mongoURI: process.env.MONGO_URI!,
  jwtSecret: process.env.JWT_SECRET!,
};
```

#### **3. Define the User Model**

**`src/models/User.ts`**

```typescript
import mongoose, { Document, Schema } from 'mongoose';

export interface IUser extends Document {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  dateOfBirth?: Date;
  gender?: 'male' | 'female';
  phoneNumber?: string;
}

const UserSchema: Schema = new Schema<IUser>(
  {
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    email: { type: String, required: true, unique: true, lowercase: true },
    password: { type: String, required: true },
    dateOfBirth: { type: Date },
    gender: { type: String, enum: ['male', 'female'] },
    phoneNumber: { type: String },
  },
  { timestamps: true }
);

export default mongoose.model<IUser>('User', UserSchema);
```

#### **4. Middleware for Authentication**

**`src/middleware/auth.ts`**

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import config from '../utils/validateEnv';
import User, { IUser } from '../models/User';

interface AuthRequest extends Request {
  user?: IUser;
}

const auth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.header('Authorization');

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'No token, authorization denied' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, config.jwtSecret) as { id: string };
    const user = await User.findById(decoded.id).select('-password');

    if (!user) {
      return res.status(401).json({ message: 'Token is not valid' });
    }

    req.user = user;
    next();
  } catch (error) {
    console.error(error);
    res.status(401).json({ message: 'Token is not valid' });
  }
};

export default auth;
```

#### **5. User Controller**

**`src/controllers/userController.ts`**

```typescript
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/User';
import config from '../utils/validateEnv';

// Helper function to generate JWT
const generateToken = (id: string) => {
  return jwt.sign({ id }, config.jwtSecret, { expiresIn: '1h' });
};

// @desc    Register new user
// @route   POST /api/signup
// @access  Public
export const signup = async (req: Request, res: Response) => {
  const { firstName, lastName, email, password } = req.body;

  try {
    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already exists' });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Create user
    const user = new User({
      firstName,
      lastName,
      email,
      password: hashedPassword,
    });

    await user.save();

    res.status(201).json({ message: 'User registered successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// @desc    Authenticate user & get token
// @route   POST /api/login
// @access  Public
export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;

  try {
    // Check for user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'Invalid Credentials' });
    }

    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid Credentials' });
    }

    // Generate JWT
    const token = generateToken(user._id);

    res.json({ token });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// @desc    Get user profile
// @route   GET /api/profile
// @access  Private
export const getProfile = async (req: Request, res: Response) => {
  const user = (req as any).user as IUser;

  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }

  res.json({
    firstName: user.firstName,
    lastName: user.lastName,
    email: user.email,
    dateOfBirth: user.dateOfBirth,
    gender: user.gender,
    phoneNumber: user.phoneNumber,
  });
};

// @desc    Update user profile
// @route   PUT /api/profile
// @access  Private
export const updateProfile = async (req: Request, res: Response) => {
  const user = (req as any).user as IUser;
  const { firstName, lastName, email, dateOfBirth, gender, phoneNumber } = req.body;

  try {
    // Check if email is being updated and if it's unique
    if (email && email !== user.email) {
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(400).json({ message: 'Email already exists' });
      }
      user.email = email;
    }

    // Update fields
    if (firstName) user.firstName = firstName;
    if (lastName) user.lastName = lastName;
    if (dateOfBirth) user.dateOfBirth = dateOfBirth;
    if (gender) user.gender = gender;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    await user.save();

    res.json({ message: 'Profile updated successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};
```

#### **6. Define Routes**

**`src/routes/userRoutes.ts`**

```typescript
import express from 'express';
import { signup, login, getProfile, updateProfile } from '../controllers/userController';
import auth from '../middleware/auth';

const router = express.Router();

// Public Routes
router.post('/signup', signup);
router.post('/login', login);

// Protected Routes
router.get('/profile', auth, getProfile);
router.put('/profile', auth, updateProfile);

export default router;
```

#### **7. Initialize Express App**

**`src/app.ts`**

```typescript
import express from 'express';
import cors from 'cors';
import userRoutes from './routes/userRoutes';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/api', userRoutes);

// Health Check Route
app.get('/', (req, res) => {
  res.send('API is running...');
});

export default app;
```

#### **8. Start the Server**

**`src/server.ts`**

```typescript
import mongoose from 'mongoose';
import app from './app';
import config from './utils/validateEnv';

const PORT = config.port;

// Connect to MongoDB
mongoose
  .connect(config.mongoURI, {
    // These options are no longer necessary in Mongoose 6+
    // useNewUrlParser: true,
    // useUnifiedTopology: true,
  })
  .then(() => {
    console.log('MongoDB connected');
    // Start server after successful DB connection
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  })
  .catch((err) => {
    console.error('MongoDB connection failed:', err.message);
    process.exit(1);
  });
```

#### **9. Scripts in `package.json`**

Add the following scripts to your `package.json` for development and production:

```json
"scripts": {
  "build": "tsc",
  "start": "node dist/server.js",
  "dev": "ts-node-dev --respawn --transpile-only src/server.ts"
},
```

- `npm run dev`: Starts the server in development mode with automatic restarts.
- `npm run build`: Compiles TypeScript to JavaScript.
- `npm start`: Starts the compiled JavaScript server.

#### **10. Running the Backend**

Ensure MongoDB is running and accessible via the connection string provided in the `.env` file.

Start the backend server in development mode:

```bash
npm run dev
```

You should see output similar to:

```
MongoDB connected
Server running on port 5000
```

#### **11. API Endpoints Summary**

1. **Signup**

   - **URL:** `POST /api/signup`
   - **Body:**
     ```json
     {
       "firstName": "John",
       "lastName": "Doe",
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```
   - **Responses:**
     - `201 Created`: User registered successfully.
     - `400 Bad Request`: Email already exists.
     - `500 Internal Server Error`: Server error.

2. **Login**

   - **URL:** `POST /api/login`
   - **Body:**
     ```json
     {
       "email": "john.doe@example.com",
       "password": "password123"
     }
     ```
   - **Responses:**
     - `200 OK`: Returns JWT token.
       ```json
       {
         "token": "your_jwt_token"
       }
       ```
     - `400 Bad Request`: Invalid credentials.
     - `500 Internal Server Error`: Server error.

3. **Get Profile**

   - **URL:** `GET /api/profile`
   - **Headers:**
     ```
     Authorization: Bearer your_jwt_token
     ```
   - **Responses:**
     - `200 OK`: Returns user profile.
       ```json
       {
         "firstName": "John",
         "lastName": "Doe",
         "email": "john.doe@example.com",
         "dateOfBirth": "1990-01-01T00:00:00.000Z",
         "gender": "male",
         "phoneNumber": "1234567890"
       }
       ```
     - `401 Unauthorized`: No token or invalid token.
     - `500 Internal Server Error`: Server error.

4. **Update Profile**

   - **URL:** `PUT /api/profile`
   - **Headers:**
     ```
     Authorization: Bearer your_jwt_token
     ```
   - **Body:** (Any fields to update)
     ```json
     {
       "firstName": "Jane",
       "lastName": "Doe",
       "email": "jane.doe@example.com",
       "dateOfBirth": "1991-02-02",
       "gender": "female",
       "phoneNumber": "0987654321"
     }
     ```
   - **Responses:**
     - `200 OK`: Profile updated successfully.
     - `400 Bad Request`: Email already exists or validation error.
     - `401 Unauthorized`: No token or invalid token.
     - `500 Internal Server Error`: Server error.

#### **12. CORS Configuration**

By default, CORS is enabled for all origins in the `app.ts` with `app.use(cors())`. If you want to restrict it to specific origins (e.g., your frontend URL), modify the CORS middleware:

```typescript
import cors from 'cors';

const app = express();

const corsOptions = {
  origin: 'http://localhost:3000', // Replace with your frontend URL
  optionsSuccessStatus: 200,
};

app.use(cors(corsOptions));
```

#### **13. Testing the API**

You can use tools like **Postman** or **Insomnia** to test the API endpoints.

**Example Workflow:**

1. **Signup:**
   - Send a `POST` request to `/api/signup` with user details.
   - On success, you should receive a success message.

2. **Login:**
   - Send a `POST` request to `/api/login` with the registered email and password.
   - On success, you receive a JWT token.

3. **Get Profile:**
   - Send a `GET` request to `/api/profile` with the `Authorization` header set to `Bearer your_jwt_token`.
   - You receive the user's profile information.

4. **Update Profile:**
   - Send a `PUT` request to `/api/profile` with updated fields and the `Authorization` header.
   - On success, you receive a success message.

#### **14. Security Considerations**

- **Password Security:** Passwords are hashed using `bcryptjs` before storing them in the database.
- **JWT Security:** Ensure that the `JWT_SECRET` is strong and kept confidential. Tokens have an expiration time (`1h` in this case).
- **Error Handling:** Avoid exposing sensitive information in error messages.
- **CORS:** Restrict CORS to only allow trusted origins.

#### **15. Deployment Considerations**

- **Environment Variables:** Ensure that environment variables are properly set in the production environment.
- **Database Security:** Secure your MongoDB instance, use environment variables for credentials, and consider using services like MongoDB Atlas.
- **HTTPS:** Serve your API over HTTPS to ensure encrypted data transmission.
- **Rate Limiting:** Implement rate limiting to protect against brute-force attacks.
- **Logging:** Implement proper logging for monitoring and debugging.

---

### Conclusion

With the above setup, you have a fully functional backend that handles user registration, authentication, profile retrieval, and profile updates securely using JWT. The frontend code provided earlier can communicate with this backend to create a complete full-stack application. Ensure to handle all edge cases and perform thorough testing to make the application robust and secure.
